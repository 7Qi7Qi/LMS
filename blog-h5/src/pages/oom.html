<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="referrer" content="no-referrer" />
  <title>高手总结的9种 OOM 常见原因及解决方案</title>

</head>
<body>
<div class="post">
  <h1 class="postTitle">

    <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/tiancai/p/14431986.html">
      <span>高手总结的9种 OOM 常见原因及解决方案</span>
    </a>

  </h1>
  <div class="clear"></div>
  <div class="postBody">
    <div>
      <div class="rno-markdown J-articleContent">
        <p>当 JVM 内存严重不足时，就会抛出 java.lang.OutOfMemoryError 错误。本文总结了常见的 OOM 原因及其解决方法，如下图所示。如有遗漏或错误，欢迎补充指正。</p>
        <div class="image-block"><span>
            <img src="../../../blog-h5/src/assets/jmm.jpeg" style="cursor: zoom-in" class="medium-zoom-image"></span></div>
        <p>1、Java heap space</p>
        <p>当堆内存（Heap Space）没有足够空间存放新创建的对象时，就会抛出 <code>java.lang.OutOfMemoryError:Javaheap space</code> 错误（根据实际生产经验，可以对程序日志中的 OutOfMemoryError 配置关键字告警，一经发现，立即处理）。</p>
        <h3>原因分析</h3>
        <p><code>Javaheap space</code> 错误产生的常见原因可以分为以下几类：</p>
        <p>1、请求创建一个超大对象，通常是一个大数组。</p>
        <p>2、超出预期的访问量/数据量，通常是上游系统请求流量飙升，常见于各类促销/秒杀活动，可以结合业务流量指标排查是否有尖状峰值。</p>
        <p>3、过度使用终结器（Finalizer），该对象没有立即被 GC。</p>
        <p>4、内存泄漏（Memory Leak），大量对象引用没有释放，JVM 无法对其自动回收，常见于使用了 File 等资源没有回收。</p>
        <h3 >解决方案</h3>
        <p>针对大部分情况，通常只需要通过 <code>-Xmx</code> 参数调高 JVM 堆内存空间即可。如果仍然没有解决，可以参考以下情况做进一步处理：</p>
        <p>1、如果是超大对象，可以检查其合理性，比如是否一次性查询了数据库全部结果，而没有做结果数限制。</p>
        <p>2、如果是业务峰值压力，可以考虑添加机器资源，或者做限流降级。</p>
        <p>3、如果是内存泄漏，需要找到持有的对象，修改代码设计，比如关闭没有释放的连接。</p>
        <h2>2、GC overhead limit exceeded</h2>
        <p>当 Java 进程花费 98% 以上的时间执行 GC，但只恢复了不到 2% 的内存，且该动作连续重复了 5 次，就会抛出 <code>java.lang.OutOfMemoryError:GC overhead limit exceeded</code> 错误。简单地说，就是应用程序已经基本耗尽了所有可用内存， GC 也无法回收。</p>
        <p>此类问题的原因与解决方案跟 <code>Javaheap space</code> 非常类似，可以参考上文。</p>
        <h2 >3、Permgen space</h2>
        <p>该错误表示永久代（Permanent Generation）已用满，通常是因为加载的 class 数目太多或体积太大。</p>
        <h3>原因分析</h3>
        <p>永久代存储对象主要包括以下几类：</p>
        <p>1、加载/缓存到内存中的 class 定义，包括类的名称，字段，方法和字节码；</p>
        <p>2、常量池；</p>
        <p>3、对象数组/类型数组所关联的 class；</p>
        <p>4、JIT 编译器优化后的 class 信息。</p>
        <p>PermGen 的使用量与加载到内存的 class 的数量/大小正相关。</p>
        <h3 >解决方案</h3>
        <p>根据 Permgen space 报错的时机，可以采用不同的解决方案，如下所示：</p>
        <p>1、程序启动报错，修改 <code>-XX:MaxPermSize</code> 启动参数，调大永久代空间。</p>
        <p>2、应用重新部署时报错，很可能是没有应用没有重启，导致加载了多份 class 信息，只需重启 JVM 即可解决。</p>
        <p>3、运行时报错，应用程序可能会动态创建大量 class，而这些 class 的生命周期很短暂，但是 JVM 默认不会卸载 class，可以设置 <code>-XX:+CMSClassUnloadingEnabled</code> 和 <code>-XX:+UseConcMarkSweepGC</code>这两个参数允许 JVM 卸载 class。</p>
        <p>如果上述方法无法解决，可以通过 jmap 命令 dump 内存对象 <code>jmap-dump:format=b,file=dump.hprof&lt;process-id&gt;</code> ，然后利用 Eclipse MAT https://www.eclipse.org/mat 功能逐一分析开销最大的 classloader 和重复 class。</p>
        <h2 >4、Metaspace</h2>
        <p>JDK 1.8 使用 Metaspace 替换了永久代（Permanent Generation），该错误表示 Metaspace 已被用满，通常是因为加载的 class 数目太多或体积太大。</p>
        <p>此类问题的原因与解决方法跟 <code>Permgenspace</code> 非常类似，可以参考上文。需要特别注意的是调整 Metaspace 空间大小的启动参数为 <code>-XX:MaxMetaspaceSize</code>。</p>
        <h2 >5、Unable to create new native thread</h2>
        <p>每个 Java 线程都需要占用一定的内存空间，当 JVM 向底层操作系统请求创建一个新的 native 线程时，如果没有足够的资源分配就会报此类错误。</p>
        <h3>原因分析</h3>
        <p>JVM 向 OS 请求创建 native 线程失败，就会抛出 <code>Unableto createnewnativethread</code>，常见的原因包括以下几类：</p>
        <p>1、线程数超过操作系统最大线程数 ulimit 限制；</p>
        <p>2、线程数超过 kernel.pid_max（只能重启）；</p>
        <p>3、native 内存不足；</p>
        <p>该问题发生的常见过程主要包括以下几步：</p>
        <p>1、JVM 内部的应用程序请求创建一个新的 Java 线程；</p>
        <p>2、JVM native 方法代理了该次请求，并向操作系统请求创建一个 native 线程；</p>
        <p>3、操作系统尝试创建一个新的 native 线程，并为其分配内存；</p>
        <p>4、如果操作系统的虚拟内存已耗尽，或是受到 32 位进程的地址空间限制，操作系统就会拒绝本次 native 内存分配；</p>
        <p>5、JVM 将抛出 <code>java.lang.OutOfMemoryError:Unableto createnewnativethread</code> 错误。</p>
        <h3 >解决方案</h3>
        <p>1、升级配置，为机器提供更多的内存；</p>
        <p>2、降低 Java Heap Space 大小；</p>
        <p>3、修复应用程序的线程泄漏问题；</p>
        <p>4、限制线程池大小；</p>
        <p>5、使用 -Xss 参数减少线程栈的大小；</p>
        <p>6、调高 OS 层面的线程最大数：执行 <code>ulimia-a</code> 查看最大线程数限制，使用 <code>ulimit-u xxx</code> 调整最大线程数限制。</p>
        <p>ulimit -a .... 省略部分内容 ..... max user processes (-u) 16384</p>
        <h2 >6、Out of swap space？</h2>
        <p>该错误表示所有可用的虚拟内存已被耗尽。虚拟内存（Virtual Memory）由物理内存（Physical Memory）和交换空间（Swap Space）两部分组成。当运行时程序请求的虚拟内存溢出时就会报 <code>Outof swap space?</code> 错误。</p>
        <h3>原因分析</h3>
        <p>该错误出现的常见原因包括以下几类：</p>
        <p>1、地址空间不足；</p>
        <p>2、物理内存已耗光；</p>
        <p>3、应用程序的本地内存泄漏（native leak），例如不断申请本地内存，却不释放。</p>
        <p>4、执行 <code>jmap-histo:live&lt;pid&gt;</code> 命令，强制执行 Full GC；如果几次执行后内存明显下降，则基本确认为 Direct ByteBuffer 问题。</p>
        <h3 >解决方案</h3>
        <p>根据错误原因可以采取如下解决方案：</p>
        <p>1、升级地址空间为 64 bit；</p>
        <p>2、使用 Arthas 检查是否为 Inflater/Deflater 解压缩问题，如果是，则显式调用 end 方法。</p>
        <p>3、Direct ByteBuffer 问题可以通过启动参数 <code>-XX:MaxDirectMemorySize</code> 调低阈值。</p>
        <p>4、升级服务器配置/隔离部署，避免争用。</p>
        <h2 >7、 Kill process or sacrifice child</h2>
        <p>有一种内核作业（Kernel Job）名为 Out of Memory Killer，它会在可用内存极低的情况下“杀死”（kill）某些进程。OOM Killer 会对所有进程进行打分，然后将评分较低的进程“杀死”，具体的评分规则可以参考 Surviving the Linux OOM Killer。</p>
        <p>不同于其他的 OOM 错误， <code>Killprocessorsacrifice child</code> 错误不是由 JVM 层面触发的，而是由操作系统层面触发的。</p>
        <h3>原因分析</h3>
        <p>默认情况下，Linux 内核允许进程申请的内存总量大于系统可用内存，通过这种“错峰复用”的方式可以更有效的利用系统资源。</p>
        <p>然而，这种方式也会无可避免地带来一定的“超卖”风险。例如某些进程持续占用系统内存，然后导致其他进程没有可用内存。此时，系统将自动激活 OOM Killer，寻找评分低的进程，并将其“杀死”，释放内存资源。</p>
        <h3 >解决方案</h3>
        <p>1、升级服务器配置/隔离部署，避免争用。</p>
        <p>2、OOM Killer 调优。</p>
        <h2 >8、Requested array size exceeds VM limit</h2>
        <p>JVM 限制了数组的最大长度，该错误表示程序请求创建的数组超过最大长度限制。</p>
        <p>JVM 在为数组分配内存前，会检查要分配的数据结构在系统中是否可寻址，通常为 <code>Integer.MAX_VALUE-2</code>。</p>
        <p>此类问题比较罕见，通常需要检查代码，确认业务是否需要创建如此大的数组，是否可以拆分为多个块，分批执行。</p>
        <h2 >9、Direct buffer memory</h2>
        <p>Java 允许应用程序通过 Direct ByteBuffer 直接访问堆外内存，许多高性能程序通过 Direct ByteBuffer 结合内存映射文件（Memory Mapped File）实现高速 IO。</p>
        <h3>原因分析</h3>
        <p>Direct ByteBuffer 的默认大小为 64 MB，一旦使用超出限制，就会抛出 <code>Directbuffer memory</code> 错误。</p>
        <h3 >解决方案</h3>
        <p>1、Java 只能通过 ByteBuffer.allocateDirect 方法使用 Direct ByteBuffer，因此，可以通过 Arthas 等在线诊断工具拦截该方法进行排查。</p>
        <p>2、检查是否直接或间接使用了 NIO，如 netty，jetty 等。</p>
        <p>3、通过启动参数 <code>-XX:MaxDirectMemorySize</code> 调整 Direct ByteBuffer 的上限值。</p>
        <p>4、检查 JVM 参数是否有 <code>-XX:+DisableExplicitGC</code> 选项，如果有就去掉，因为该参数会使 <code>System.gc()</code> 失效。</p>
        <p>5、检查堆外内存使用代码，确认是否存在内存泄漏；或者通过反射调用 <code>sun.misc.Cleaner</code> 的 <code>clean()</code> 方法来主动释放被 Direct ByteBuffer 持有的内存空间。</p>
        <p>6、内存容量确实不足，升级配置。</p>
      </div>
      <h3 class="header-title" title="高手总结的9种 OOM 常见原因及解决方案">高手总结的9种 OOM 常见原因及解决方案</h3>
    </div>
    <div class="clear"></div>
    <div id="blog_post_info_block"><div id="BlogPostCategory">
      分类:
      <a href="https://www.cnblogs.com/tiancai/category/1248620.html" target="_blank">jvm</a></div>
      <div id="EntryTag">
        标签:
        <a href="https://www.cnblogs.com/tiancai/tag/jvm/">jvm</a></div>

    </div>
  </div>

</div>
</body>
</html>
